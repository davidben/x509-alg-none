{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-08T01:27:49.237852+00:00",
  "repo": "davidben/x509-alg-none",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOM9--mM6c0X-3",
      "title": "Talk about using id-unsigned for making a self-signed-ness determination",
      "url": "https://github.com/davidben/x509-alg-none/issues/1",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/IiHCjkChIO7vNsio3jqDJ3daGwE/\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/zL_PEDX_xzuXt08jth91HPzOP5I/\r\n\r\n> The phrase \u201cshould change nothing\u201d caught my eye. Fortunately, the draft does not say this. The context implicitly referenced here is when validating a path or determining the authenticity of a trust anchor. A signature may be checked for other purposes. For example, self-signed-ness may be checked to decide how to handle a cert in support of basic cert store hygiene when installing a certificate (i.e., one doesn\u2019t need a self-signed cert in a pile of intermediates). Those apps would need to change. I think the draft should add some words about the need to recognize id-unsigned where use of self-signed-ness determination (i.e., signature verification) serves purposes other than validating a path or establishing a trust anchor\u2019s authenticity.\r\n\r\n> This is true, but some applications (like the Windows certificate viewer) give an integrity error if you replace a self-signed cert\u2019s algorithm and signature with an unrecognized OID and an empty BIT STRING. This application would need to change as a negative indicator like that may create confusion for some users when installing or viewing a root.\r\n\r\n\r\n",
      "createdAt": "2024-11-03T05:04:02Z",
      "updatedAt": "2025-03-25T03:13:29Z",
      "closedAt": "2025-03-25T03:13:29Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOM9--mM6c0YQw",
      "title": "id-alg-noSignature specifies a hash as a \"signature\"",
      "url": "https://github.com/davidben/x509-alg-none/issues/2",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "id-alg-noSignature actually (somewhat pointlessly it seems) uses a hash of the input as the signature:\r\nhttps://www.rfc-editor.org/rfc/rfc5272.html#appendix-C.1\r\n\r\nDo we still reuse the OID (to avoid defining multiple OIDs with very similar names and purposes) and live with diverging here, or do we make a new OID?",
      "createdAt": "2024-11-03T05:08:17Z",
      "updatedAt": "2025-05-06T18:37:46Z",
      "closedAt": "2025-05-06T18:37:45Z",
      "comments": [
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "I am in favor of the current state in v01 because\n* it leaves out the useless and confusing hash value loosely defined in [RFC 5272 appendix C.1](https://datatracker.ietf.org/doc/html/rfc5272#appendix-C.1) for signature-less CSRs\n* it defines its own OID to point out the difference that there is no hash here. ",
          "createdAt": "2025-03-21T04:35:19Z",
          "updatedAt": "2025-03-21T04:35:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Sounds like this is what most people are happy with, so closing this.",
          "createdAt": "2025-05-06T18:37:45Z",
          "updatedAt": "2025-05-06T18:37:45Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOM9--mM6c0YW3",
      "title": "Generalize to CSRs",
      "url": "https://github.com/davidben/x509-alg-none/issues/3",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Some folks on LAMPS want to apply this to yet another square-peg-in-round-hole situation that X.509 keeps finding itself in. This, however, is only applicable in cases where you _were not verifying the signature in the CSR_. Otherwise, this unsigned CSR has different properties.",
      "createdAt": "2024-11-03T05:09:49Z",
      "updatedAt": "2025-05-06T18:38:19Z",
      "closedAt": "2025-05-06T18:38:18Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Note generalizing to CSRs may run into https://github.com/davidben/x509-alg-none/issues/2. But if that has already been defined for CSRs, maybe we don't need this.",
          "createdAt": "2024-11-03T05:11:08Z",
          "updatedAt": "2024-11-03T05:11:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Closing this since it sounds like folks are fine leaving it as-is. We can always write another document if needed.",
          "createdAt": "2025-05-06T18:38:18Z",
          "updatedAt": "2025-05-06T18:38:18Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOM9--mM6roNU_",
      "title": "Guidance on issuer field",
      "url": "https://github.com/davidben/x509-alg-none/issues/5",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "What to put in the issuer field is an interesting question because there is no issuer. Right now we just don't say anything. I can think of a few options:\n\n* Copy the subject. This is most similar to self-signed certificates, but it is kind of a waste\n* Empty issuer. This isn't allowed by RFC 5280 and likely has compatibility implications\n* A well-defined short placeholder\n* Don't say anything and leave it as an exercise for the reader (status quo)",
      "createdAt": "2025-02-25T20:00:37Z",
      "updatedAt": "2025-05-07T20:26:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ghen2",
          "authorAssociation": "NONE",
          "body": "\"Copy the subject\" may not work for EE certificates, where Subject is on the way out, superseded by SAN.\n\"Empty issuer\" seems most obvious, but isn't allowed.  So perhaps best to specify a fixed placeholder issuer, which also helps to distinguish \"no signature\" from \"unknown signature algorithm\".  (and could be linked to #6 to give this thing a common name.)",
          "createdAt": "2025-02-26T19:26:33Z",
          "updatedAt": "2025-02-26T19:26:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Wrote some \"eh, whatever\" text to start with in https://github.com/davidben/x509-alg-none/commit/465030b947e619bdee082057e66e3d359123395b. A fixed placeholder might not be wrong either, but I stopped short of picking one of those. :-)",
          "createdAt": "2025-03-25T03:33:09Z",
          "updatedAt": "2025-03-25T03:33:09Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "NONE",
          "body": "1. document a fixed placeholder to be used if nothing else works.\n2. for a proper trust anchor (CA), then the Issuer should == Subject, and that should be a common situation.\n\n3. there are perhaps other strange exceptions, such as when replacing one trust anchor with another (RFC4210 section 4.4) where one trust anchor signs the new one.  During the overlap period, the new trust anchor is actually signed with the old, so it would not have alg-none.  But, afterwards, it becomes a trust anchor, so alg-none is correct, but it might be easier to find the right entry to delete if it matches Issuer/Subject as before.  This is perhaps a difficult to defend option.",
          "createdAt": "2025-03-27T18:52:14Z",
          "updatedAt": "2025-03-27T18:52:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> document a fixed placeholder to be used if nothing else works.\n\nSure. Any preference for which? I guess we can just allocate a attribute with type = id-unsigned?\n\n> for a proper trust anchor (CA), then the Issuer should == Subject, and that should be a common situation.\n\nHmm, can you clarify? Is there a specification prescribes that a trust anchor (as opposed to a self-signed certificate, which is something else) must have issuer == subject?\n\nA trust anchor isn't an X.509 certificate in the first place. It's purely subject information. That mismatch is the point of this document. We happen to represent them as self-signed X.509 certificates, but that's a syntactic hack. When we choose that syntactic hack, issuer == subject. This document exists to provide a more efficient (but no less unsound) syntactic hack.\n\nIt's true that some _implementations_ have, based on that syntactic hack, treated subject == issuer special in interpreting their own local configuration. It may even be convenient to set issuer == subject to be compatible with those implementations! But local configuration is ultimately, well, local, and implementations can choose to do what they like, including rewriting the trust anchor to whatever form is convenient for them.\n\n> there are perhaps other strange exceptions, such as when replacing one trust anchor with another (RFC4210 section 4.4) where one trust anchor signs the new one. During the overlap period, the new trust anchor is actually signed with the old, so it would not have alg-none. But, afterwards, it becomes a trust anchor, so alg-none is correct, but it might be easier to find the right entry to delete if it matches Issuer/Subject as before. This is perhaps a difficult to defend option.\n\nI think it's worth very precise here to describe what is going on. It's, I think, less strange than you describe. Nothing changes form here.\n\nIn this scenario, there are two CAs: Old and New. CAs are not certificates. They are nodes in the PKI graph described by a name, public key, and perhaps other subject information (SKID, etc.). Nodes do not have issuer fields in the first place, so it is not meaningful to say what their issuer is.\n\nSome relying parties have Old as a trust anchor, and some have New. In each of those relying parties, they have local configuration that contains Old and/or New's subject information in whatever form those applications use. That form could be:\n* a self-signed certificate (in which case issuer == subject and we have the wasteful self-signature)\n* an unsigned certificate (in which case issuer is... whatever we pick for this issue, and there is no signature)\n* not as a certificate at all (e.g. RFC 5914).\n\nDuring a transition from Old-as-a-trust-anchor to New-as-a-trust-anchor, it is useful to issue a cross-certificate from Old to New. That is an actual certificate, an edge in the PKI graph, where Old signs the information in New. The cross-certificate is a bona fide signed certificate, with meaningful issuer fields, and everything, and this draft doesn't apply. This isn't a trust anchor, but an edge from one CA to another.\n\nMultiple objects may describe the same X.509 entity's subject information. The cross certificates in the second case and the various representations in the first case are not the same object, and that's fine. Their connection is that they both contain the same subject information, but they are consumed by different applications. The cross-certificate is not local configuration but part of the certificate chain being validated.\n",
          "createdAt": "2025-03-27T19:16:52Z",
          "updatedAt": "2025-03-27T19:19:41Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "NONE",
          "body": "> > document a fixed placeholder to be used if nothing else works.\n> \n> Sure. Any preference for which? I guess we can just allocate a attribute with type = id-unsigned?\n> \n> > for a proper trust anchor (CA), then the Issuer should == Subject, and that should be a common situation.\n> \n> Hmm, can you clarify? Is there a specification prescribes that a trust anchor (as opposed to a self-signed certificate, which is something else) must have issuer == subject?\n\nIt's that a self-signed certificate has issuer==Subject, and simplifying expectations has value.\n\n> A trust anchor isn't an X.509 certificate in the first place. It's purely subject information. That mismatch is the point of this document. We happen to represent them as self-signed X.509 certificates, but that's a syntactic hack. When we choose that syntactic hack, issuer == subject. This document exists to provide a more efficient (but no less unsound) syntactic hack.\n\nso I understand, which is why #1 is the preferred mechanism.\nbut, for situations where that does not work for some reason, then issuer==subject.\n\n> It's true that some _implementations_ have, based on that syntactic hack, treated subject == issuer special in interpreting their own local configuration. It may even be convenient to set issuer == subject to be compatible with those implementations! But local configuration is ultimately, well, local, and implementations can choose to do what they like, including rewriting the trust anchor to whatever form is convenient for them.\n\nThis is what I'm saying too.\n\n> \n> > there are perhaps other strange exceptions, such as when replacing one trust anchor with another (RFC4210 section 4.4) where one trust anchor signs the new one. During the overlap period, the new trust anchor is actually signed with the old, so it would not have alg-none. But, afterwards, it becomes a trust anchor, so alg-none is correct, but it might be easier to find the right entry to delete if it matches Issuer/Subject as before. This is perhaps a difficult to defend option.\n> \n> I think it's worth very precise here to describe what is going on. It's, I think, less strange than you describe. Nothing changes form here.\n\nIn the RFC4210 change of CA, which is really update trust anchors, one starts by signing the new CA with the old CA.\nThat means that the new CA arrives at some systems not as a (fiat) trust anchor, but as a subordinate CA.\nLater, that system gets the new *trust anchor*, and really it then needs to replace the old trust anchor with the new one.  The new one is already authenticated by being signed with the old one.  So having it *match* the subordinate certificate might be a feature.\n(Later on, new CA signs oldCA, and old CA is removed as a trust anchor)\n",
          "createdAt": "2025-03-28T11:06:45Z",
          "updatedAt": "2025-03-28T11:06:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "> It's that a self-signed certificate has issuer==Subject, and simplifying expectations has value.\n\n> so I understand, which is why https://github.com/davidben/x509-alg-none/issues/1 is the preferred mechanism.\n> but, for situations where that does not work for some reason, then issuer==subject.\n\nAh, sure. I think we're on the same page there. That's what I was trying to capture by allowing a couple of options and not really prescribing anything, but I guess I forgot to give any reason for why you might want to do it. I think I'd meant for the \"needed for compatibility with existing applications\" clause to apply to the whole paragraph but that got lost in wordsmithing. Perhaps...\n\n> An unsigned certificate has no issuer, so there no meaningful values to use for the issuer and issuerUniqueID fields and the authority key identifier and issuer alternative name extensions. This document does not mandate particular values but gives general guidance:\n>\n> Senders SHOULD set these fields to minimize the size of the certificate:\n>\n> * The issuer field may not be empty, so it is set to a short placeholder value [[TODO: Suggest a value?]]\n> * The authority key identifier extension is omitted\n>\n> However, if needed for compatibility with existing applications, senders MAY instead set these fields as in a self-signed certificate. That is:\n>\n> * The issuer field is a copy of the subject field (if not empty)\n> * The authority key identifier extension matches the subject key identifier, or is omitted\n>\n> {{!RFC5280}} prohibits setting issuerUniqueID and does not incorporate issuer alternate names in path validation, so senders SHOULD omit both unless needed for compatibility with existing applications.\n\nRe RFC4210...\n\n> In the RFC4210 change of CA, which is really update trust anchors, one starts by signing the new CA with the old CA.\n> That means that the new CA arrives at some systems not as a (fiat) trust anchor, but as a subordinate CA.\n> Later, that system gets the new trust anchor, and really it then needs to replace the old trust anchor with the new one. The new one is already authenticated by being signed with the old one. So having it match the subordinate certificate might be a feature.\n> (Later on, new CA signs oldCA, and old CA is removed as a trust anchor)\n\nHmm, I may have missed it, but RFC4210 doesn't seem to particular prescribe matching operations when using a subordinate certificate to bootstrap believe in a corresponding trust anchor. Matching _everything_ doesn't make much sense. I mean, even if you make the names match (which... has problems, please don't do that!), the AKID extension is not going to match between the two.\n\nThough hopefully \"compatibility with existing applications\" covers any weird applications that might have matched the name anyway. (But, seriously, please don't reuse the name when minting a new CA. It causes so many problems.)",
          "createdAt": "2025-03-29T16:04:47Z",
          "updatedAt": "2025-03-29T16:04:47Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> \"Copy the subject\" may not work for EE certificates, where Subject is on the way out, superseded by SAN. \n\nWhen copying the subject Distinguished Name (DN) to the issuer DN, no need to copy also any SAN extensions, \nso no issue from that angle, but as mentioned for the first option:\n\n> * Copy the subject. This is most similar to self-signed certificates, but it is kind of a waste\n\nthis would be a waste, and moreover it would be similarly confusing as a self-signature.\nSo for both these reasons, not the best option.\n\n>\"Empty issuer\" seems most obvious, but isn't allowed.\n\nWell, it depends on what is meant by \"empty issuer\" and by \"not allowed\".\nNote that semantic requirements by X.509 and RFC 5280 do not apply to trust anchors (TAs) even if TAs have the format of an X.509 public-key certificate - TAs have been explicitly exempted from these.\n\nEven when using that format, from a syntactic perspective an \"empty\" issuer can be represented easily:\nnot by omitting the `issuer` field, which indeed would not be possible because it is non-optional,\nbut as a so-called \"NULL-DN\", which is a zero-length SEQUENCE OF RelativeDistinguishedNames (RDNs), \nwith the DER encoding consisting of two bytes: 0x30 0x00.\n\n> So perhaps best to specify a fixed placeholder issuer, which also helps to distinguish \"no signature\" from \"unknown signature algorithm\". (and could be linked to [#6](https://github.com/davidben/x509-alg-none/issues/6) to give this thing a common name.)\n\nYes - the NULL-DN can serve for this purpose. It is the shortest and simplest such placeholder.\nTherefore I see it as the canonical choice. In a sense, it covers options 2 and/or 3:\n\n> * Empty issuer. [...]\n> * A well-defined short placeholder\n\nThe fourth option:\n\n> * Don't say anything and leave it as an exercise for the reader (status quo)\n\nis not desirable because it just defers a solution and would bear the strong risk of leading to confusion and incompatibility.\n\nSo in my view, placing the NULL-DN value in the `issuer` field is clearly the best option.\n\n\n",
          "createdAt": "2025-04-12T19:43:38Z",
          "updatedAt": "2025-04-12T19:43:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "@DDvO By \"empty issuer\" I mean NULL-DN and by \"not allowed\" I mean that RFC 5280 forbids it:\n\n>    The issuer field identifies the entity that has signed and issued the\n>   certificate.  The issuer field MUST contain a non-empty distinguished\n>   name (DN).\n\nBecause of that, I do not think we can reasonably use that as the placeholder value.\n\n> Note that semantic requirements by X.509 and RFC 5280 do not apply to trust anchors (TAs) even if TAs have the format of an X.509 public-key certificate - TAs have been explicitly exempted from these.\n\nWhile that's true, I expect that this would trip enough linters and strict parsers that it would probably cause more trouble than is worth it to use it here. It's a pity, because I would otherwise agree that NULL-DN would be a natural placeholder here.",
          "createdAt": "2025-05-06T18:56:53Z",
          "updatedAt": "2025-05-06T18:56:53Z"
        },
        {
          "author": "ghen2",
          "authorAssociation": "NONE",
          "body": "Also, the use case is not only trust anchors, but also generic self-signed (ie. not CA-issued) certificates for TLS servers.  So X.509 semantics are indeed relevant here.",
          "createdAt": "2025-05-06T19:22:58Z",
          "updatedAt": "2025-05-06T19:22:58Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I agree we can't get away from wanting this to work when subject == issuer for compatibility. by supporting that we can still use this with years and years of validators that do not check signature and would otherwise need an update to understand a fixed value.  So imo the guidance should be either subject == issuer, or a chosen defined \"This is not signed by anything\" DN which sadly can not be the NULL-DN. ",
          "createdAt": "2025-05-07T16:34:23Z",
          "updatedAt": "2025-05-07T16:34:23Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> [@DDvO](https://github.com/DDvO) By \"empty issuer\" I mean NULL-DN and by \"not allowed\" I mean that RFC 5280 forbids it:\n> \n> > The issuer field identifies the entity that has signed and issued the\n> > certificate.  The issuer field MUST contain a non-empty distinguished\n> > name (DN).\n> \n> Because of that, I do not think we can reasonably use that as the placeholder value.\n> \n> > Note that semantic requirements by X.509 and RFC 5280 do not apply to trust anchors (TAs) even if TAs have the format of an X.509 public-key certificate - TAs have been explicitly exempted from these.\n\nThe statement that \"RFC 5280 forbids NULL-DN\" for the issuer field of a cert used as a TA is wrong.\nAlso the sentence \"`{{!RFC5280}} does not permit empty issuers.`\" in the [proposed text](https://github.com/davidben/x509-alg-none/commit/465030b947e619bdee082057e66e3d359123395b) is wrong and misleading. It should be re-phrased to give the real reason.\n\nAgain, RFC 5280 does not apply to TA certs, and thus the above mentioned requirement from its [section 4.1.2.4](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.4) does NOT apply.\nFor data structures that look like an X.509 public-key cert but are just trust anchors, alleged X.509 / RFC 5280 requirements  \n are nothing but a very widespread misinterpretation.\n\n> While that's true, I expect that this would trip enough linters and strict parsers that it would probably cause more trouble than is worth it to use it here.\n\nI just had a look at the OpenSSL implementation and found that non-emptiness of the issuer DN ist not checked by default,\nbut with the `X509_V_FLAG_X509_STRICT` flag (or `-x509_strict` CLI option, respectively), unfortunately this does get checked also for trust anchor certs.\nI must admit that it was me who [added this check to `x509_vfy.c`](https://github.com/openssl/openssl/blob/d56f9b4d894d1a3ce92f1c308ef42398495943e7/crypto/x509/x509_vfy.c#L666)  (and several related checks) \nwhile at that time not being aware myself that all those checks should not be applied to TA certs at the end of the chain.\n\n> It's a pity, because I would otherwise agree that NULL-DN would be a natural placeholder here.\n\nYes, it's a pity that for pragmatic reasons (namely, likely wrong TA cert checks in various implementations)\nit will not be feasible to use NULL-DN here.\n",
          "createdAt": "2025-05-07T18:19:06Z",
          "updatedAt": "2025-05-07T18:19:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "I suppose whether rules for public key certificates apply when you use a public key certificate to represent a trust anchor, even though trust anchors aren't public key certificates, is one of those great philosophical debates that it's best to avoid stepping into. \ud83d\ude06 \n\nFWIW, I checked the ITU specification and it says:\n\n> IETF RFC 5914 defines trust anchor information as a choice among three alternatives:\n>\n> ```\n> TrustAnchorChoice ::= CHOICE {\n>  certificate Certificate,\n>  tbsCert [1] EXPLICIT TBSCertificate,\n>  taInfo [2] EXPLICIT TrustAnchorInfo }\n> ```\n> The certificate alternative specifies a public-key certificate that can be either a self-signed certificate or a public-key\ncertificate.\n> The tbsCert alternative specifies an unsigned public-key certificate as defined in clause 7.2.\n> NOTE 3 \u2013 This alternative is deprecated by this Specification and therefore not considered further.\n> The taInfo alternative specifies a special trust anchor information format defined by IETF RFC 5914.\n> If the trust anchor information is not used for signing public-key certificates, it shall be an end-entity public-key certificate.\n\nThat seems to suggest that this \"is\" a public-key certificate. The ITU definition of a public-key certificate has the same prohibition, so it's not just the RFC 5280 profile of X.509:\n\n> The issuer component shall hold the distinguished name of the CA that issued the public-key certificate. It shall hold a\nnon-empty distinguished name.\n\nSo I think parsers that forbid NULL-DN here are on regrettably solid footing. Do you think it still makes sense to soften the proposed text, given that? If so, how do you feel about:\n\n> {{!RFC5280}} does not permit empty issuers, so doing so may not be interoperable with some receivers. Senders MAY use the subject field (though note the subject may be empty), as in a self-signed certificate, or instead use a short placeholder value.\n\n(Reasoning: I couldn't think of a crisp way to qualify the first sentence, and it seems unambiguously true that RFC5280 forbids it, just unclear whether it applies, so I added another clause to emphasize that we're mostly concerned about interoperability.)",
          "createdAt": "2025-05-07T20:24:55Z",
          "updatedAt": "2025-05-07T20:26:25Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOM9--mM6roNtA",
      "title": "Rename unsigned to... something",
      "url": "https://github.com/davidben/x509-alg-none/issues/6",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There's some chatter on LAMPS about a better name instead of \"unsigned certificates\". Filing this to remember there's a decision point here.",
      "createdAt": "2025-02-25T20:01:28Z",
      "updatedAt": "2025-05-06T18:38:44Z",
      "closedAt": "2025-05-06T18:38:43Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Sounds like things have largely settled on \"unsigned\". Closing this until some other thoughts crop up.",
          "createdAt": "2025-05-06T18:38:43Z",
          "updatedAt": "2025-05-06T18:38:43Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOM9--mM6sIDb9",
      "title": "Add the edges vs nodes analogy directly in draft",
      "url": "https://github.com/davidben/x509-alg-none/issues/7",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See feedback here https://mailarchive.ietf.org/arch/msg/spasm/ZcHAMeEent8_3353leFp7ZIDqUI/",
      "createdAt": "2025-02-28T18:11:26Z",
      "updatedAt": "2025-03-20T09:24:32Z",
      "closedAt": "2025-03-20T09:24:32Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "(Holding this to after adoption call resolves one way or another.)",
          "createdAt": "2025-02-28T18:13:51Z",
          "updatedAt": "2025-02-28T18:13:51Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOM9--mM6MWSy8",
      "title": "subtle change to the intent of the OID",
      "url": "https://github.com/davidben/x509-alg-none/pull/4",
      "state": "MERGED",
      "author": "frumioj",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I feel like it's not so much on what the consumer should do, but more about what the sender is indicating - \"I didn't sign this because I'm not expecting you to validate my signature\" (or \"Too Long, Didn't Send\"?)",
      "createdAt": "2025-02-24T20:25:06Z",
      "updatedAt": "2025-05-07T22:44:54Z",
      "baseRepository": "davidben/x509-alg-none",
      "baseRefName": "main",
      "baseRefOid": "7d8b64eeaab6a8ea1be29f560cabd9b26871da21",
      "headRepository": "frumioj/x509-alg-none",
      "headRefName": "patch-1",
      "headRefOid": "e770f21d66ef4c5c6abefbe3744d4b2457d20609",
      "closedAt": "2025-05-06T18:37:08Z",
      "mergedAt": "2025-05-06T18:37:08Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "743b6e81c8b5002523e46bb1347b1dc408f05422"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "Ah whoops, I forgot that one of the consequences of waiting to do the draft-ietf version first is that now we have a merge conflict. :-( Do you mind rebasing and updating? Thanks!",
          "createdAt": "2025-03-20T07:42:53Z",
          "updatedAt": "2025-03-20T07:42:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "OWNER",
          "body": "(Figured out how to merge this without rebasing the PR.)",
          "createdAt": "2025-05-06T18:37:20Z",
          "updatedAt": "2025-05-06T18:37:20Z"
        },
        {
          "author": "frumioj",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for figuring this out @davidben since I clearly didn't get a chance to rebase/update!",
          "createdAt": "2025-05-07T22:44:52Z",
          "updatedAt": "2025-05-07T22:44:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOM9--mM6dRR2c",
          "commit": {
            "abbreviatedOid": "e770f21"
          },
          "author": "davidben",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Ah yeah that's a good change. I will hold off on merging it *quite* yet, just because the document is mid adoption call and, in the past, people have gotten antsy about unexpected changes between `draft-davidben-...-N` and `draft-ietf-...-00`. But will merge after that.",
          "createdAt": "2025-02-24T22:07:03Z",
          "updatedAt": "2025-02-24T22:07:03Z",
          "comments": []
        }
      ]
    }
  ]
}